# 消息通知持久化修复说明

## 问题描述

之前存在的问题：回收员（工作人员）读取消息后，每次重新登录时，数字消息提示仍然会出现。这是因为系统没有正确追踪和显示消息的已读状态。

**期望的效果**：
- 工作人员读取消息后标记为已读
- 已读的消息不应该在重新登录后再次显示数字提示
- 只有新的未读消息才应该显示数字徽章

## 解决方案

### 实现的功能

1. **数据访问层 (MessageDAL.cs)**
   - 新增 `GetRecyclerUnreadCount(int recyclerId)` 方法
   - 统计指定回收员的未读消息数量（按订单ID去重）
   - 只统计用户发送给回收员的未读消息（IsRead = 0）

2. **业务逻辑层 (MessageBLL.cs)**
   - 新增 `GetRecyclerUnreadCount(int recyclerId)` 方法
   - 包含参数验证逻辑

3. **控制器层 (StaffController.cs)**
   - 新增 `GetRecyclerUnreadCount()` AJAX接口
   - 包含角色验证，只允许回收员访问
   - 返回JSON格式：`{ success: true/false, unreadCount: number }`

4. **视图层 (_RecyclerLayout.cshtml)**
   - 在导航栏"消息中心"旁边添加消息徽章
   - 添加CSS样式显示红色数字徽章
   - 添加JavaScript自动加载未读消息数
   - 每60秒自动刷新一次
   - 当计数为0时，徽章自动隐藏

5. **消息中心页面 (Message_Center.cshtml)**
   - 读取消息后自动更新徽章

### 技术细节

#### 数据库查询逻辑
```sql
SELECT COUNT(DISTINCT m.OrderID) 
FROM Messages m
INNER JOIN Appointments a ON m.OrderID = a.AppointmentID
WHERE a.RecyclerID = @RecyclerID 
  AND m.SenderType != 'recycler'
  AND m.IsRead = 0
```

**查询说明**：
- 按订单ID去重统计（同一订单多条未读消息只计为1）
- 只统计分配给该回收员的订单
- 只统计用户发送的消息（SenderType != 'recycler'）
- 只统计未读消息（IsRead = 0）

#### 工作流程

1. 回收员登录后，页面自动加载未读消息数
2. 未读数显示为红色徽章，位于"消息中心"链接旁边
3. 回收员打开某个订单的对话时，该订单的消息被标记为已读（IsRead = 1）
4. 已读状态持久化到数据库
5. 徽章立即更新，减少相应的未读数
6. 回收员退出登录后再次登录，只显示真正未读的消息数
7. 系统每60秒自动刷新一次徽章（避免遗漏新消息）

### 视觉效果

**徽章样式**：
- 位置：消息中心链接的右上角
- 颜色：红色背景 (#dc3545)，白色文字
- 形状：圆角矩形
- 内容：未读消息数（超过99显示"99+"）
- 空状态：当未读数为0时，徽章自动隐藏

### 安全性

- ✅ 通过CodeQL安全扫描（0个漏洞）
- ✅ 实施角色访问控制（只有回收员可以访问）
- ✅ Session验证确保用户已登录
- ✅ 一致的错误处理机制

## 测试步骤

### 前置条件
- 需要至少两个账号：一个普通用户账号和一个回收员账号
- 用户需要创建至少一个订单并被回收员接单

### 测试场景1：基本功能测试

1. **普通用户发送消息**
   - 以普通用户身份登录
   - 进入"我的订单"，选择一个进行中的订单
   - 发送消息给回收员

2. **回收员查看未读数**
   - 以回收员身份登录
   - 观察导航栏"消息中心"旁边是否显示红色徽章
   - 验证徽章数字是否正确

3. **读取消息**
   - 点击"消息中心"
   - 点击左侧有未读消息的订单
   - 观察对话内容加载

4. **验证徽章更新**
   - 徽章数字应该减少或消失（如果没有其他未读消息）

### 测试场景2：重新登录测试（核心场景）

1. **读取消息后退出**
   - 确保已经读取了所有消息（徽章为0或不显示）
   - 点击"退出登录"

2. **重新登录**
   - 以相同的回收员账号重新登录
   - **关键验证**：导航栏"消息中心"旁边不应该显示徽章
   - 如果没有新消息，徽章应该保持隐藏状态

3. **发送新消息并验证**
   - 切换到普通用户账号
   - 发送新消息
   - 切换回回收员账号（或等待60秒自动刷新）
   - 验证徽章重新出现并显示正确的未读数

### 测试场景3：多订单测试

1. **创建多个订单**
   - 用户创建3个订单，都被同一个回收员接单
   - 在每个订单中发送消息

2. **验证计数**
   - 回收员登录后，徽章应该显示"3"（3个订单有未读消息）

3. **部分读取**
   - 读取其中2个订单的消息
   - 徽章应该更新为"1"

4. **重新登录验证**
   - 退出并重新登录
   - 徽章应该显示"1"（而不是"3"）

### 测试场景4：自动刷新测试

1. **保持页面打开**
   - 回收员登录并停留在任意页面
   
2. **其他用户发送消息**
   - 用另一个用户账号发送消息

3. **等待60秒**
   - 观察徽章是否自动更新
   - 应该显示新的未读消息数

### 预期结果

✅ **成功标准**：
- 读取后的消息不会在重新登录时再次显示
- 徽章数字准确反映未读消息数
- 徽章在没有未读消息时自动隐藏
- 新消息到达时徽章正确显示
- 自动刷新机制正常工作

❌ **失败情况**：
- 如果已读消息在重新登录后仍显示，则说明存在问题
- 如果徽章数字不准确，需要检查数据库IsRead字段
- 如果徽章不更新，检查JavaScript控制台错误

## 代码变更文件

1. `recycling.DAL/MessageDAL.cs` - 添加未读消息计数查询
2. `recycling.BLL/MessageBLL.cs` - 添加业务逻辑方法
3. `recycling.Web.UI/Controllers/StaffController.cs` - 添加AJAX接口
4. `recycling.Web.UI/Views/Shared/_RecyclerLayout.cshtml` - 添加徽章显示和脚本
5. `recycling.Web.UI/Views/Staff/Message_Center.cshtml` - 添加徽章刷新调用

## 技术栈

- **后端**：ASP.NET MVC, C#, SQL Server
- **前端**：JavaScript (Vanilla), HTML, CSS
- **数据库**：SQL Server (使用ADO.NET)

## 注意事项

1. **数据库表结构**：此修复依赖于Messages表的IsRead字段，确保数据库表结构正确
2. **Session管理**：需要确保Session["LoginStaff"]和Session["StaffRole"]正确设置
3. **浏览器兼容性**：JavaScript使用现代浏览器API，建议使用Chrome、Firefox、Edge等现代浏览器
4. **性能考虑**：60秒自动刷新对服务器负载影响很小，但在高并发场景下可以考虑增加间隔或使用WebSocket

## 后续优化建议

1. **实时通知**：考虑使用SignalR实现真正的实时推送，替代60秒轮询
2. **消息预览**：在徽章悬停时显示最新消息预览
3. **声音提醒**：新消息到达时播放提示音
4. **桌面通知**：使用浏览器通知API实现桌面提醒
5. **消息分类**：区分不同类型的消息（系统消息、用户消息等）

## 总结

此修复彻底解决了消息通知在重新登录后重复出现的问题。通过在数据库级别持久化消息的已读状态，并在前端正确显示，确保了用户体验的连贯性和一致性。该方案已通过代码审查和安全检查，可以安全部署到生产环境。
