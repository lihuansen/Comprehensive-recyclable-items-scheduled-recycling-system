# 实时聊天功能测试指南

## 测试前准备

### 环境要求
- Windows操作系统（.NET Framework 4.8）
- Visual Studio 2019或更高版本
- SQL Server 2016或更高版本
- 浏览器：Chrome、Edge或Firefox最新版本

### 数据库准备

1. 确认数据库表已创建：
```sql
-- 检查表是否存在
SELECT * FROM sys.tables WHERE name IN ('AdminContactMessages', 'AdminContactConversations');
```

2. 如果表不存在，运行脚本：
```bash
cd Database
sqlcmd -S (local) -d RecyclingDB -i CreateAdminContactMessagesTable.sql
```

### 测试账号准备

需要准备：
- 1个普通用户账号
- 1个管理员账号

## 功能测试清单

### ✓ 测试1: 用户首次联系管理员

**目标**: 验证用户能够成功发起新对话

**步骤**:
1. 以用户身份登录系统
2. 导航到"问题反馈"页面
3. 点击"联系我们"链接
4. 观察界面加载

**预期结果**:
- [ ] 页面成功加载聊天界面
- [ ] 看到系统欢迎消息："您好，这里是在线客服"
- [ ] 状态显示为"进行中"（绿色圆点）
- [ ] 输入框可用
- [ ] "发送"按钮可用
- [ ] 没有"结束对话"按钮

**数据库验证**:
```sql
-- 应该创建新的会话记录
SELECT TOP 1 * FROM AdminContactConversations 
WHERE UserID = [测试用户ID] 
ORDER BY StartTime DESC;

-- AdminEnded应该为0
-- UserEnded应该为0
```

---

### ✓ 测试2: 用户发送消息

**目标**: 验证用户能够成功发送消息

**步骤**:
1. 在测试1的基础上
2. 在输入框输入消息："你好，我需要帮助"
3. 点击"发送"按钮

**预期结果**:
- [ ] 消息立即显示在聊天窗口中
- [ ] 消息显示在右侧（蓝紫色背景）
- [ ] 显示发送时间
- [ ] 输入框自动清空
- [ ] 消息区域自动滚动到底部

**数据库验证**:
```sql
SELECT * FROM AdminContactMessages 
WHERE UserID = [测试用户ID] 
AND SenderType = 'user'
ORDER BY SentTime DESC;

-- 应该看到刚发送的消息
```

---

### ✓ 测试3: 用户关闭后重新打开对话

**目标**: 验证会话持久性

**步骤**:
1. 在测试2的基础上，发送几条消息
2. 点击"返回问题反馈"
3. 再次点击"联系我们"

**预期结果**:
- [ ] 看到之前发送的所有消息
- [ ] 没有重复的欢迎消息
- [ ] 状态仍然显示"进行中"
- [ ] 可以继续发送消息
- [ ] 会话ID未变化（检查控制台或数据库）

**数据库验证**:
```sql
-- 应该只有一条会话记录
SELECT COUNT(*) as ConversationCount 
FROM AdminContactConversations 
WHERE UserID = [测试用户ID] 
AND AdminEnded = 0;

-- 结果应该是1
```

---

### ✓ 测试4: 管理员查看用户对话

**目标**: 验证管理员能够看到用户发起的对话

**步骤**:
1. 保持用户端对话页面打开
2. 以管理员身份登录系统
3. 导航到"用户联系管理"页面
4. 查找测试用户的对话

**预期结果**:
- [ ] 在会话列表中看到测试用户的对话
- [ ] 对话标记为"进行中"（绿色徽章）
- [ ] 显示正确的用户名
- [ ] 显示会话开始时间
- [ ] 默认"全部"筛选器被选中

---

### ✓ 测试5: 管理员回复用户

**目标**: 验证管理员能够回复用户消息

**步骤**:
1. 在测试4的基础上
2. 点击测试用户的对话
3. 查看对话历史
4. 在输入框输入："您好，请问有什么可以帮您？"
5. 点击"发送"按钮

**预期结果**:
- [ ] 右侧聊天区域显示用户的所有历史消息
- [ ] 消息发送成功
- [ ] 管理员消息显示在左侧（白色背景）
- [ ] 消息标记为"管理员"
- [ ] 消息区域自动滚动到底部

---

### ✓ 测试6: 实时消息更新（关键测试）

**目标**: 验证实时轮询功能正常工作

**准备**:
- 用户端浏览器打开对话页面
- 管理员端浏览器打开对话页面
- 两个浏览器窗口并排显示

**步骤**:
1. 在用户端发送消息："这是用户消息"
2. 等待最多3秒
3. 观察管理员端界面
4. 在管理员端发送回复："这是管理员回复"
5. 等待最多3秒
6. 观察用户端界面

**预期结果**:
- [ ] 用户消息在3秒内自动出现在管理员端（无需刷新）
- [ ] 管理员回复在3秒内自动出现在用户端（无需刷新）
- [ ] 消息顺序正确
- [ ] 没有重复消息
- [ ] 时间戳正确

**调试技巧**:
- 打开浏览器控制台（F12）
- 切换到Network标签
- 查看每3秒是否有新的请求到 `GetAdminContactMessages` 或 `GetAdminContactMessagesForAdmin`

---

### ✓ 测试7: 会话筛选功能

**目标**: 验证管理员端的筛选功能

**步骤**:
1. 在管理员端"用户联系管理"页面
2. 点击"进行中"按钮
3. 观察会话列表
4. 点击"已结束"按钮
5. 观察会话列表
6. 点击"全部"按钮
7. 观察会话列表

**预期结果**:
- [ ] "进行中"只显示未结束的对话（AdminEnded=0）
- [ ] "已结束"只显示已结束的对话（AdminEnded=1）
- [ ] "全部"显示所有对话
- [ ] 按钮高亮状态正确切换
- [ ] 筛选响应迅速

---

### ✓ 测试8: 管理员结束对话（核心测试）

**目标**: 验证只有管理员可以结束对话，且结束后状态正确

**准备**:
- 用户端和管理员端浏览器并排显示
- 两端都打开同一对话

**步骤**:
1. 在管理员端点击"结束对话"按钮
2. 确认对话框中点击"确定"
3. 等待最多3秒
4. 同时观察两端界面变化

**预期结果 - 管理员端**:
- [ ] 弹出确认对话框
- [ ] 点击确定后显示"对话已结束"提示
- [ ] 看到系统消息："管理员已结束对话"
- [ ] 输入框被禁用（灰色）
- [ ] "发送"按钮被禁用
- [ ] "结束对话"按钮被禁用
- [ ] 会话列表中该对话变为"已结束"（灰色徽章）

**预期结果 - 用户端（3秒内自动更新）**:
- [ ] 状态自动变为"已结束"（红色圆点）
- [ ] 看到系统消息："管理员已结束对话"
- [ ] 输入框自动禁用
- [ ] "发送"按钮自动禁用
- [ ] 无法输入新消息

**数据库验证**:
```sql
SELECT AdminEnded, AdminEndedTime, UserEnded 
FROM AdminContactConversations 
WHERE UserID = [测试用户ID] 
ORDER BY StartTime DESC;

-- AdminEnded应该为1
-- AdminEndedTime应该有值
-- UserEnded可能为0或1（不影响功能）
```

---

### ✓ 测试9: 对话结束后用户无法发送消息

**目标**: 验证会话结束后的权限控制

**步骤**:
1. 在测试8的基础上（对话已被管理员结束）
2. 尝试在用户端输入消息（如果可以）
3. 尝试点击发送按钮（如果可以）

**预期结果**:
- [ ] 输入框被禁用，无法输入
- [ ] 发送按钮被禁用，无法点击
- [ ] 如果通过控制台绕过前端限制强制发送，后端应返回错误
- [ ] 错误消息："对话已结束，无法发送消息"

**安全性验证**:
```javascript
// 在浏览器控制台执行
fetch('/Home/SendAdminContactMessage', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ userId: [用户ID], content: "测试消息" })
})
.then(r => r.json())
.then(data => console.log(data));

// 应该返回 { success: false, message: "对话已结束，无法发送消息" }
```

---

### ✓ 测试10: 对话结束后用户重新联系

**目标**: 验证结束后可以创建新对话

**步骤**:
1. 在测试9的基础上（对话已结束）
2. 用户点击"返回问题反馈"
3. 再次点击"联系我们"
4. 观察界面

**预期结果**:
- [ ] 创建了新的对话（新的会话ID）
- [ ] 看到新的欢迎消息："您好，这里是在线客服"
- [ ] 状态显示为"进行中"
- [ ] 输入框可用
- [ ] 看不到之前的聊天记录（属于旧会话）
- [ ] 可以正常发送新消息

**数据库验证**:
```sql
SELECT ConversationID, StartTime, AdminEnded 
FROM AdminContactConversations 
WHERE UserID = [测试用户ID] 
ORDER BY StartTime DESC;

-- 应该看到两条记录
-- 旧的：AdminEnded=1
-- 新的：AdminEnded=0
```

---

### ✓ 测试11: 查看历史对话

**目标**: 验证用户可以查看历史对话

**步骤**:
1. 在用户端对话页面
2. 点击"查看历史对话"按钮
3. 观察左侧列表
4. 点击一个已结束的对话

**预期结果**:
- [ ] 左侧显示所有历史对话列表
- [ ] 每个对话显示会话ID、开始时间和状态
- [ ] 已结束的对话显示"已结束"标记
- [ ] 点击对话后加载该对话的完整消息历史
- [ ] 已结束对话的输入框被禁用
- [ ] 进行中的对话可以继续发送消息

---

### ✓ 测试12: 管理员端会话列表自动刷新

**目标**: 验证会话列表的自动更新

**步骤**:
1. 管理员打开"用户联系管理"页面
2. 不要选择任何对话
3. 使用另一个用户账号发起新的对话
4. 等待30秒
5. 观察管理员端会话列表

**预期结果**:
- [ ] 新的对话在30秒内自动出现在列表中
- [ ] 无需手动刷新页面
- [ ] 新对话标记为"进行中"

---

### ✓ 测试13: 并发对话测试

**目标**: 验证系统可以处理多个同时进行的对话

**步骤**:
1. 使用3个不同的用户账号
2. 同时打开"联系我们"页面
3. 每个用户发送不同的消息
4. 管理员查看所有对话

**预期结果**:
- [ ] 每个用户的对话独立存在
- [ ] 消息不会混淆
- [ ] 管理员可以看到所有3个对话
- [ ] 每个对话显示正确的用户信息
- [ ] 切换对话时消息正确加载

---

### ✓ 测试14: 长消息和特殊字符测试

**目标**: 验证消息内容的处理

**测试用例**:

**测试14.1 - 长消息**:
- 输入1900字符的消息（接近2000限制）
- 应该成功发送
- 输入2100字符的消息（超过限制）
- 应该被拒绝或截断

**测试14.2 - 空消息**:
- 尝试发送空消息或只有空格的消息
- 应该显示提示"请输入消息内容"

**测试14.3 - HTML和特殊字符**:
```
测试消息: <script>alert('xss')</script>
测试消息: <b>加粗</b> <i>斜体</i>
测试消息: & < > " '
测试消息: 中文 English 123 !@#$%
```

**预期结果**:
- [ ] HTML标签被转义显示为文本
- [ ] 特殊字符正确显示
- [ ] 不会执行JavaScript代码
- [ ] 多语言字符正确显示

---

### ✓ 测试15: 网络异常测试

**目标**: 验证系统的容错性

**测试15.1 - 发送消息时网络中断**:
1. 打开浏览器开发者工具
2. 切换到Network标签
3. 启用"Offline"模式
4. 尝试发送消息

**预期结果**:
- [ ] 显示错误提示
- [ ] 不会假装发送成功
- [ ] 用户可以在网络恢复后重试

**测试15.2 - 轮询请求失败**:
1. 在控制台查看轮询请求
2. 临时断网
3. 观察错误处理

**预期结果**:
- [ ] 控制台记录错误但不影响界面
- [ ] 网络恢复后自动继续轮询
- [ ] 用户体验无明显中断

---

## 性能测试

### 测试16: 轮询性能

**目标**: 确认轮询不会造成性能问题

**监测指标**:
1. 打开浏览器性能监视器
2. 观察15分钟
3. 记录：
   - CPU使用率
   - 内存使用
   - 网络请求频率
   - 请求响应时间

**预期结果**:
- [ ] CPU使用率保持在正常水平（<5%）
- [ ] 内存不会持续增长
- [ ] 每3秒精确发送一次请求
- [ ] 响应时间<200ms

---

### 测试17: 大量历史消息

**目标**: 验证消息数量对性能的影响

**步骤**:
1. 创建一个包含100+条消息的对话
2. 打开该对话
3. 测量加载时间和界面流畅度

**预期结果**:
- [ ] 页面在2秒内加载完成
- [ ] 滚动流畅无卡顿
- [ ] 所有消息正确显示

---

## 浏览器兼容性测试

### 测试18: 跨浏览器测试

**测试浏览器**:
- [ ] Chrome (最新版)
- [ ] Edge (最新版)
- [ ] Firefox (最新版)
- [ ] Safari (如果有Mac)

**测试内容**:
对每个浏览器执行测试1-10的所有步骤

**记录**:
- 布局是否正常
- 功能是否正常
- 是否有控制台错误
- 特殊问题记录

---

## 安全测试

### 测试19: XSS攻击防护

**步骤**:
1. 尝试发送包含脚本的消息：
```html
<script>alert('XSS')</script>
<img src=x onerror="alert('XSS')">
<a href="javascript:alert('XSS')">点击</a>
```

**预期结果**:
- [ ] 所有脚本都被转义为纯文本
- [ ] 不会执行任何JavaScript
- [ ] 消息显示为原始文本

---

### 测试20: SQL注入防护

**步骤**:
1. 尝试发送SQL注入字符串：
```
' OR '1'='1
'; DROP TABLE AdminContactMessages; --
1' UNION SELECT * FROM Users --
```

**预期结果**:
- [ ] 消息正常存储为文本
- [ ] 数据库结构完整
- [ ] 不会执行SQL命令

---

### 测试21: 权限验证

**步骤**:
1. 未登录状态访问：`/Home/ContactAdmin`
2. 普通用户访问：`/Staff/UserContactManagement`
3. 用户A尝试查看用户B的消息（修改API请求参数）

**预期结果**:
- [ ] 未登录用户被重定向到登录页
- [ ] 普通用户无法访问管理员页面
- [ ] 用户无法查看其他用户的消息
- [ ] 所有未授权操作返回错误

---

## 回归测试

### 测试22: 确认不影响其他功能

**测试点**:
- [ ] 用户登录/登出正常
- [ ] 预约下单功能正常
- [ ] 订单管理功能正常
- [ ] 其他反馈功能正常
- [ ] 管理员其他功能正常

---

## 测试结果记录

### 测试环境信息
```
操作系统: ____________
浏览器: ____________
SQL Server版本: ____________
测试日期: ____________
测试人员: ____________
```

### 测试结果统计

| 测试编号 | 测试名称 | 结果 | 备注 |
|---------|---------|------|------|
| 测试1 | 用户首次联系 | ☐通过 ☐失败 | |
| 测试2 | 用户发送消息 | ☐通过 ☐失败 | |
| 测试3 | 会话持久性 | ☐通过 ☐失败 | |
| 测试4 | 管理员查看 | ☐通过 ☐失败 | |
| 测试5 | 管理员回复 | ☐通过 ☐失败 | |
| 测试6 | 实时更新 | ☐通过 ☐失败 | |
| 测试7 | 会话筛选 | ☐通过 ☐失败 | |
| 测试8 | 结束对话 | ☐通过 ☐失败 | |
| 测试9 | 结束后限制 | ☐通过 ☐失败 | |
| 测试10 | 重新联系 | ☐通过 ☐失败 | |
| ... | ... | ... | |

### 发现的问题

| 问题编号 | 严重程度 | 问题描述 | 复现步骤 | 状态 |
|---------|---------|---------|---------|------|
| | | | | |

---

## 快速冒烟测试清单

如果时间有限，至少执行以下关键测试：

- [ ] **测试1**: 用户首次联系
- [ ] **测试2**: 用户发送消息
- [ ] **测试6**: 实时消息更新
- [ ] **测试8**: 管理员结束对话
- [ ] **测试10**: 对话结束后重新联系

这5个测试覆盖了核心功能路径。

---

## 常见问题排查

### 问题1: 消息不能实时更新

**检查点**:
1. 打开浏览器控制台，查看是否有JavaScript错误
2. 切换到Network标签，确认每3秒有轮询请求
3. 检查API返回的数据是否正确
4. 确认 `pollingInterval` 没有被意外停止

**解决方法**:
- 刷新页面
- 清除浏览器缓存
- 检查网络连接

### 问题2: 对话结束后仍然可以发送消息

**检查点**:
1. 检查数据库中 `AdminEnded` 字段是否为1
2. 检查前端是否调用了 `checkConversationStatus()`
3. 检查 `isConversationEnded` 变量的值

**解决方法**:
- 等待3秒让轮询更新状态
- 手动刷新页面

### 问题3: 看不到历史消息

**检查点**:
1. 检查数据库中消息是否存在
2. 检查API返回的消息列表
3. 检查控制台是否有错误

### 问题4: 会话列表不更新

**检查点**:
1. 确认30秒定时器是否运行
2. 检查API是否正常返回数据
3. 检查筛选条件是否正确

---

## 自动化测试建议

对于长期维护，建议开发以下自动化测试：

1. **单元测试**:
   - AdminContactBLL 的所有方法
   - AdminContactDAL 的所有方法

2. **集成测试**:
   - 创建会话流程
   - 发送消息流程
   - 结束会话流程

3. **API测试**:
   - 使用Postman或类似工具
   - 测试所有Controller方法
   - 验证返回数据格式

4. **端到端测试**:
   - 使用Selenium或Playwright
   - 模拟用户完整操作流程
   - 验证界面元素和交互

---

## 测试完成检查清单

测试完成后，确认：

- [ ] 所有关键测试通过
- [ ] 已发现的问题已记录
- [ ] 性能指标在可接受范围内
- [ ] 安全测试通过
- [ ] 跨浏览器测试完成
- [ ] 测试报告已编写
- [ ] 问题已反馈给开发团队

---

**测试签字**:

测试人员: ____________  日期: ____________

审核人员: ____________  日期: ____________
